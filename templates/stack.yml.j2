AWSTemplateFormatVersion: "2010-09-09"

Description: Intake API - {{ env }}

Parameters:
  ApplicationImageId:
    Type: String
    Description: Application Amazon Machine Image ID
  ApplicationInstanceType:
    Type: String
    Description: Application EC2 Instance Type
  ApplicationDesiredCount:
    Type: Number
    Description: Application AutoScaling Group Desired Count
    Default: 1
  ApplicationDockerImage:
    Type: String
    Description: Docker Image for Application
  ApplicationDockerImageTag:
    Type: String
    Description: Docker Image Tag for Application
    Default: latest
  ApplicationKeyName:
    Type: String
    Description: EC2 Key Pair for Application SSH Access
  ApplicationLoadBalancerPort:
    Type: Number
    Description: Application Front End HTTP Port
  ApplicationLoadBalancerCertificateArn:
    Type: String
    Description: Name of CloudFormation export with Application Load Balancer certificate ARN
  ApplicationPort:
    Type: Number
    Description: Application HTTP Port
  ApplicationHostname:
    Type: String
    Description: Host portion of the application URL
  ApplicationDomain:
    Type: String
    Description: Base public domain of the application URL
  ApplicationSecretKey:
    Type: String
    Description: KMS Encrypted Secret Key Base
  ElasticsearchImageId:
    Type: String
    Description: Elasticsearch Amazon Machine Image ID
  ElasticsearchInstanceType:
    Type: String
    Description: Elasticsearch EC2 Instance Type
  ElasticsearchDesiredCount:
    Type: Number
    Description: Elasticsearch AutoScaling Group Desired Count
  ElasticsearchDockerImage:
    Type: String
    Description: Docker Image for Elasticsearch
  ElasticsearchDockerImageTag:
    Type: String
    Description: Docker Image Tag for Elasticsearch
    Default: latest
  ElasticsearchKeyName:
    Type: String
    Description: EC2 Key Pair for Elasticsearch SSH Access
  ElasticsearchLoadBalancerPort:
    Type: Number
    Description: Elasticsearch Front End HTTP Port
  ElasticsearchPort:
    Type: Number
    Description: Elasticsearch Port
  ElasticsearchHostname:
    Type: String
    Description: Host portion of the Elasticsearch URL
  LogRetention:
    Type: Number
    Description: Log retention in days
  NginxDockerImage:
    Type: String
    Description: Docker Image for Nginx
  NginxDockerImageTag:
    Type: String
    Description: Docker Image Tag for Nginx
    Default: latest
  DbStorage:
    Type: Number
    Description: Database Allocated Storage
  DbInstanceType:
    Type: String
    Description: Database Instance Type
  DbName:
    Type: String
    Description: Database Name
  DbUsername:
    Type: String
    Description: Database Username
  DbPassword:
    Type: String
    NoEcho: "True"
    Description: Encrypted Database Password
  DbMultiAz:
    Type: String
    Description: Enable/disable database multi AZ operation
    Default: "False"
    AllowedValues: ["True", "False"]
  LambdaCfnKmsDecryptVersion:
    Type: String
    Description: S3 Object Version of CloudFormation KMS Decrypt function
  LambdaCfnEcsTasksVersion:
    Type: String
    Description: S3 Object Version of CloudFormation ECS Tasks function

Conditions:
  ApplicationSingleInstanceCondition:
    Fn::Equals:
      - Ref: ApplicationDesiredCount
      - 1
  ElasticsearchSingleInstanceCondition:
    Fn::Equals:
      - Ref: ElasticsearchDesiredCount
      - 1
  DbMultiAzCondition:
    Fn::Equals:
      - Ref: DbMultiAz
      - "true"

Resources:
  ApplicationCluster:
    Type: Stack::Transform
    Template: asg.yml.j2
    Properties:
      Name: ApplicationCluster
      CloudwatchAlarms:
        Ref: CloudwatchAlarms
      DesiredCount:
        Ref: ApplicationDesiredCount
      ImageId:
        Ref: ApplicationImageId
      InstanceType:
        Ref: ApplicationInstanceType
      KeyName:
        Ref: ApplicationKeyName
      Subnets: Medium
      ProxyEnabled: "True"
      ProxyUrl:
        Fn::ImportValue: DefaultProxyURL
      VpcName: Default

  ApplicationDnsRecord:
    Type: "AWS::Route53::RecordSet"
    Properties:
      Name: 
        Fn::Sub: "${ApplicationHostname}.${ApplicationDomain}"
      TTL: "300"
      HostedZoneName: 
        Fn::Sub: "${ApplicationDomain}."
      Type: "CNAME"
      Comment: 
        Fn::Sub: "Intake API Application - ${AWS::StackName}"
      ResourceRecords: 
        - Fn::Sub: "${ApplicationLoadBalancer.DNSName}"
  ApplicationLoadBalancer:
    Type: "AWS::ElasticLoadBalancingV2::LoadBalancer"
    Properties:
      Scheme: "internet-facing"
      SecurityGroups:
       - Ref: "ApplicationLoadBalancerSecurityGroup"
      Subnets:
        - Fn::ImportValue: DefaultPublicSubnetA
        - Fn::ImportValue: DefaultPublicSubnetB
      LoadBalancerAttributes: 
        - Key: "deletion_protection.enabled"
          Value: false
        - Key: "idle_timeout.timeout_seconds"
          Value: 30
      Tags:
        - Key: "Name"
          Value:
            Fn::Sub: ${AWS::StackName}-lb
  ApplicationLoadBalancerApplicationListener:
    Type: "AWS::ElasticLoadBalancingV2::Listener"
    Properties:
      Certificates:
        - CertificateArn:
            Fn::ImportValue:
              Ref: ApplicationLoadBalancerCertificateArn
      DefaultActions:
        - TargetGroupArn: { "Ref": "IntakeApiServiceTargetGroup" }
          Type: forward
      LoadBalancerArn: { "Ref": "ApplicationLoadBalancer" }
      Port: { "Ref": "ApplicationLoadBalancerPort" }
      Protocol: "HTTPS"
  IntakeApiServiceTargetGroup:
    Type: "AWS::ElasticLoadBalancingV2::TargetGroup"
    Properties:
      VpcId:
        Fn::ImportValue: "DefaultVpcId"
      Protocol: "HTTP"
      Port: { "Ref": "ApplicationPort" }
      HealthCheckPath: "/api/v1/screenings"
      TargetGroupAttributes:
        - Key: "deregistration_delay.timeout_seconds"
          Value: 60
  ApplicationLoadBalancerSecurityGroup:
    Type: "AWS::EC2::SecurityGroup"
    Properties:
      VpcId:
        Fn::ImportValue: "DefaultVpcId"
      GroupDescription: "Intake API Load Balancer Security Group"
      SecurityGroupIngress:
        - IpProtocol: "tcp"
          FromPort: { "Ref": "ApplicationLoadBalancerPort" }
          ToPort: { "Ref": "ApplicationLoadBalancerPort" }
          CidrIp: "0.0.0.0/0"
  ApplicationLoadBalancerToApplicationIngress:
    Type: "AWS::EC2::SecurityGroupIngress"
    Properties:
      IpProtocol: "tcp"
      FromPort: { "Ref": "ApplicationPort" }
      ToPort: { "Ref": "ApplicationPort" }
      GroupId: { "Ref": "ApplicationClusterSecurityGroup" }
      SourceSecurityGroupId: { "Ref": "ApplicationLoadBalancerSecurityGroup" }
  ApplicationLoadBalancerToApplicationEgress:
    Type: "AWS::EC2::SecurityGroupEgress"
    Properties:
      IpProtocol: "tcp"
      FromPort: { "Ref": "ApplicationPort" }
      ToPort: { "Ref": "ApplicationPort" }
      GroupId: { "Ref": "ApplicationLoadBalancerSecurityGroup" }
      DestinationSecurityGroupId: { "Ref": "ApplicationClusterSecurityGroup" }
  ApplicationToElasticsearchLoadBalancerIngress:
    Type: "AWS::EC2::SecurityGroupIngress"
    Properties:
      IpProtocol: "tcp"
      FromPort: { "Ref": "ElasticsearchLoadBalancerPort"}
      ToPort: { "Ref": "ElasticsearchLoadBalancerPort"}
      GroupId: { "Ref": "ElasticsearchLoadBalancerSecurityGroup" }
      SourceSecurityGroupId: { "Ref": "ApplicationClusterSecurityGroup" }
  ApplicationToElasticsearchLoadBalancerEgress:
    Type: "AWS::EC2::SecurityGroupEgress"
    Properties:
      IpProtocol: "tcp"
      FromPort: { "Ref": "ElasticsearchLoadBalancerPort"}
      ToPort: { "Ref": "ElasticsearchLoadBalancerPort"}
      GroupId: { "Ref": "ApplicationClusterSecurityGroup" }
      DestinationSecurityGroupId: { "Ref": "ElasticsearchLoadBalancerSecurityGroup" }
  ElasticsearchDnsRecord:
    Type: "AWS::Route53::RecordSet"
    Properties:
      Name:
        Fn::Join: ["", [
          "Fn::Sub": "${ElasticsearchHostname}.",
          "Fn::ImportValue": "DefaultVpcDomain"
        ] ]
      TTL: "300"
      HostedZoneName:
        Fn::ImportValue: DefaultVpcZone
      Type: "CNAME"
      Comment: 
        Fn::Sub: "Intake API Elasticsearch - ${AWS::StackName}"
      ResourceRecords: 
        - Fn::Sub: "${ElasticsearchLoadBalancer.DNSName}"
  ElasticsearchLoadBalancer:
    Type: "AWS::ElasticLoadBalancingV2::LoadBalancer"
    Properties:
      Scheme: "internal"
      SecurityGroups:
       - Ref: "ElasticsearchLoadBalancerSecurityGroup"
      Subnets:
        - Fn::ImportValue: DefaultHighSubnetA
        - Fn::ImportValue: DefaultHighSubnetB
      LoadBalancerAttributes: 
        - Key: "deletion_protection.enabled"
          Value: false
        - Key: "idle_timeout.timeout_seconds"
          Value: 30
      Tags:
        - Key: "Name"
          Value:
            Fn::Sub: ${AWS::StackName}-elasticsearch-lb
  ElasticsearchLoadBalancerListener:
    Type: "AWS::ElasticLoadBalancingV2::Listener"
    Properties:
      DefaultActions:
        - TargetGroupArn: { "Ref": "ElasticsearchServiceTargetGroup" }
          Type: forward
      LoadBalancerArn: { "Ref": "ElasticsearchLoadBalancer" }
      Port: { "Ref": "ElasticsearchLoadBalancerPort" }
      Protocol: "HTTP"
  ElasticsearchServiceTargetGroup:
    Type: "AWS::ElasticLoadBalancingV2::TargetGroup"
    Properties:
      VpcId:
        Fn::ImportValue: "DefaultVpcId"
      Protocol: "HTTP"
      Port: { "Ref": "ElasticsearchPort" }
      TargetGroupAttributes:
        - Key: "deregistration_delay.timeout_seconds"
          Value: 60
  ElasticsearchLoadBalancerSecurityGroup:
    Type: "AWS::EC2::SecurityGroup"
    Properties:
      VpcId:
        Fn::ImportValue: "DefaultVpcId"
      GroupDescription: "Intake API Elasticsearch Load Balancer Security Group"
  ElasticsearchLoadBalancerToElasticsearchIngress:
    Type: "AWS::EC2::SecurityGroupIngress"
    Properties:
      IpProtocol: "tcp"
      FromPort: { "Ref": "ElasticsearchPort" }
      ToPort: { "Ref": "ElasticsearchPort" }
      GroupId: { "Ref": "ElasticsearchClusterSecurityGroup" }
      SourceSecurityGroupId: { "Ref": "ElasticsearchLoadBalancerSecurityGroup" }
  ElasticsearchLoadBalancerToElasticsearchEgress:
    Type: "AWS::EC2::SecurityGroupEgress"
    Properties:
      IpProtocol: "tcp"
      FromPort: { "Ref": "ElasticsearchPort" }
      ToPort: { "Ref": "ElasticsearchPort" }
      GroupId: { "Ref": "ElasticsearchLoadBalancerSecurityGroup" }
      DestinationSecurityGroupId: { "Ref": "ElasticsearchClusterSecurityGroup" }
  
  ElasticsearchCluster:
    Type: Stack::Transform
    Template: asg.yml.j2
    Properties:
      Name: ElasticsearchCluster
      CloudwatchAlarms:
        Ref: CloudwatchAlarms
      DesiredCount:
        Ref: ElasticsearchDesiredCount
      ImageId:
        Ref: ElasticsearchImageId
      InstanceType:
        Ref: ElasticsearchInstanceType
      KeyName:
        Ref: ElasticsearchKeyName
      Subnets: High
      ProxyEnabled: "True"
      ProxyUrl:
        Fn::ImportValue: DefaultProxyURL
      VpcName: Default

  ApplicationDatabase:
    Type: "AWS::RDS::DBInstance"
    DeletionPolicy: Delete
    Properties:
      AllocatedStorage: { "Ref": "DbStorage" }
      AutoMinorVersionUpgrade: "true"
      BackupRetentionPeriod: "7"
      PreferredBackupWindow: "9:00-11:00"
      PreferredMaintenanceWindow: "sun:11:30-sun:13:00"
      StorageType: "gp2"
      DBInstanceClass: { "Ref": "DbInstanceType" }
      Engine: "postgres"
      EngineVersion: "9.5"
      MasterUsername: { "Ref": "DbUsername" }
      MasterUserPassword:
        Fn::Sub: ${DbPasswordDecrypt.Plaintext}
      DBSubnetGroupName: { "Ref": "ApplicationDatabaseSubnetGroup" }
      VPCSecurityGroups:
        - { "Ref" : "ApplicationDatabaseSecurityGroup" }
      MultiAZ: { "Ref": "DbMultiAz" }
      AvailabilityZone: 
        Fn::If:
          - "DbMultiAzCondition"
          - Ref: "AWS::NoValue"
          - Fn::Sub: "${AWS::Region}a"
      Tags:
        - Key: "Name"
          Value: "{{ 'intake-api-' + env + '-ApplicationDatabase' }}"
  ApplicationDatabaseSubnetGroup:
    Type: "AWS::RDS::DBSubnetGroup"
    Properties:
      DBSubnetGroupDescription: "{{ 'intake-api-' + env + '-ApplicationDatabase-db-subnet-group' }}"
      SubnetIds: 
        - Fn::ImportValue: DefaultHighSubnetA
        - Fn::ImportValue: DefaultHighSubnetB
      Tags:
        - Key: "Name"
          Value: "{{ 'intake-api-' + env + '-ApplicationDatabase-db-subnet-group' }}"
  ApplicationDatabaseSecurityGroup:
    Type: "AWS::EC2::SecurityGroup"
    Properties:
      GroupDescription: "{{ 'intake-api-' + env + '-ApplicationDatabase-sg' }}"
      VpcId:
        Fn::ImportValue: DefaultVpcId
      SecurityGroupEgress:
        - IpProtocol: "icmp"
          FromPort: -1
          ToPort: -1
          CidrIp: "192.0.2.0/24"
      Tags:
        - Key: "Name"
          Value: "{{ 'intake-api-' + env + '-ApplicationDatabase-sg' }}"
  ApplicationClusterToApplicationDatabaseIngressTcp5432:
    Type: "AWS::EC2::SecurityGroupIngress"
    Properties:
      IpProtocol: "tcp"
      FromPort: "5432"
      ToPort: "5432"
      GroupId: { "Ref": "ApplicationDatabaseSecurityGroup" }
      SourceSecurityGroupId: { "Ref": "ApplicationClusterSecurityGroup" }
  ApplicationClusterToApplicationDatabaseEgressTcp5432:
    Type: "AWS::EC2::SecurityGroupEgress"
    Properties:
      IpProtocol: "tcp"
      FromPort: "5432"
      ToPort: "5432"
      GroupId: { "Ref": "ApplicationClusterSecurityGroup" }
      DestinationSecurityGroupId: { "Ref": "ApplicationDatabaseSecurityGroup" }
  ApplicationTaskDefinition:
    Type: "AWS::ECS::TaskDefinition"
    Properties:
      NetworkMode: host
      Volumes:
        - Name: webroot
          Host: {}
      ContainerDefinitions:
      - Name: intake-api
        Image:
          Fn::Sub: ${ApplicationDockerImage}:${ApplicationDockerImageTag}
        MemoryReservation: 500
        LogConfiguration:
          LogDriver: awslogs
          Options:
            awslogs-group: 
              Fn::Sub: ${AWS::StackName}/ecs/IntakeApiService/intake-api
            awslogs-region: { "Ref": "AWS::Region" }
            awslogs-stream-prefix: docker
        Environment:
          - Name: RAILS_ENV
            Value: production
          - Name: PG_HOST
            Value:
              Fn::Sub: ${ApplicationDatabase.Endpoint.Address}
          - Name: DATABASE_NAME
            Value: { "Ref": "DbName" }
          - Name: PG_USER
            Value: { "Ref": "DbUsername" }
          - Name: KMS_PG_PASSWORD
            Value: { "Ref": "DbPassword" }
          - Name: KMS_SECRET_KEY_BASE
            Value: { "Ref": "ApplicationSecretKey" }
          - Name: ELASTICSEARCH_URL
            Value:
              Fn::Join: ["", [
                "http://",
                "Fn::Sub": "${ElasticsearchHostname}.",
                "Fn::ImportValue": "DefaultVpcDomain", ":",
                "Ref": "ElasticsearchPort"
              ] ]
          - Name: AWS_DEFAULT_REGION
            Value: { "Ref": "AWS::Region" }
          - Name: http_proxy
            Value:
              Fn::ImportValue: "DefaultProxyURL"
          - Name: https_proxy
            Value:
              Fn::ImportValue: "DefaultProxyURL"
          - Name: no_proxy
            Value:
              Fn::Join: ["", [
                "169.254.169.254,",
                "Fn::Sub": "${ElasticsearchHostname}.",
                "Fn::ImportValue": "DefaultVpcDomain"
              ] ]
          - Name: CLEAR_PROXY
            Value: "true"
        MountPoints:
          - SourceVolume: webroot
            ContainerPath: /tmp
        Command:
          - bundle
          - exec
          - puma
          - -v
          - -e
          - production
          - -b
          - unix:///tmp/app.sock
          - -C
          - config/puma.rb
      - Name: nginx
        Image:
          Fn::Sub: ${NginxDockerImage}:${NginxDockerImageTag}
        MemoryReservation: 200
        LogConfiguration:
          LogDriver: awslogs
          Options:
            awslogs-group: 
              Fn::Sub: ${AWS::StackName}/ecs/IntakeApiService/nginx
            awslogs-region: { "Ref": "AWS::Region" }
            awslogs-stream-prefix: docker
        PortMappings:
        - ContainerPort: { "Ref": "ApplicationPort" }
          Protocol: tcp
        Environment:
          - Name: HTTP_PORT 
            Value: { "Ref": "ApplicationPort" }
          - Name: WEB_ROOT
            Value: /intake_api_prototype/public
          - Name: UPSTREAM_URL
            Value: unix:///tmp/app.sock
          - Name: HEALTHCHECK
            Value: 
              Fn::Sub: curl -fs localhost:${ApplicationPort}/api/v1/screenings
        MountPoints:
          - SourceVolume: webroot
            ContainerPath: /tmp
        VolumesFrom:
          - SourceContainer: intake-api
            ReadOnly: "true"
  AdhocTaskDefinition:
    Type: "AWS::ECS::TaskDefinition"
    Properties:
      NetworkMode: host
      ContainerDefinitions:
      - Name: intake-api
        Image:
          Fn::Sub: ${ApplicationDockerImage}:${ApplicationDockerImageTag}
        MemoryReservation: 100
        LogConfiguration:
          LogDriver: awslogs
          Options:
            awslogs-group: 
              Fn::Sub: ${AWS::StackName}/ecs/IntakeApiService/adhoc
            awslogs-region: { "Ref": "AWS::Region" }
            awslogs-stream-prefix: docker
        Environment:
          - Name: RAILS_ENV
            Value: production
          - Name: PG_HOST
            Value:
              Fn::Sub: ${ApplicationDatabase.Endpoint.Address}
          - Name: DATABASE_NAME
            Value: { "Ref": "DbName" }
          - Name: PG_USER
            Value: { "Ref": "DbUsername" }
          - Name: KMS_PG_PASSWORD
            Value: { "Ref": "DbPassword" }
          - Name: ELASTICSEARCH_URL
            Value:
              Fn::Join: ["", [
                "http://",
                "Fn::Sub": "${ElasticsearchHostname}.",
                "Fn::ImportValue": "DefaultVpcDomain", ":",
                "Ref": "ElasticsearchPort"
              ] ]
          - Name: AWS_DEFAULT_REGION
            Value: { "Ref": "AWS::Region" }
          - Name: http_proxy
            Value:
              Fn::ImportValue: "DefaultProxyURL"
          - Name: https_proxy
            Value:
              Fn::ImportValue: "DefaultProxyURL"
          - Name: no_proxy
            Value:
              Fn::Join: ["", [
                "169.254.169.254,",
                "Fn::Sub": "${ElasticsearchHostname}.",
                "Fn::ImportValue": "DefaultVpcDomain"
              ] ]
          - Name: CLEAR_PROXY
            Value: "true"
  IntakeApiService:
    Type: "AWS::ECS::Service"
    DependsOn:
      - ApplicationLoadBalancer
      - ApplicationClusterAutoscalingGroup
      - IntakeApiServiceLogGroup
      - IntakeApiNginxLogGroup
      - DbCreateTask
      - DbMigrateTask
      - SearchMigrateTask
      - SearchReindexTask
    Properties:
      Cluster: { "Ref": "ApplicationClusterEcsCluster" }
      TaskDefinition: { "Ref": "ApplicationTaskDefinition" }
      DesiredCount: { "Ref": "ApplicationDesiredCount"}
      DeploymentConfiguration:
          MinimumHealthyPercent:
            Fn::If:
              - "ApplicationSingleInstanceCondition"
              - 0
              - 50
          MaximumPercent: 200
      LoadBalancers:
        - ContainerName: nginx
          ContainerPort: { "Ref": "ApplicationPort" }
          TargetGroupArn: { "Ref": "IntakeApiServiceTargetGroup" }
      Role: { "Ref": "EcsServiceRole" }
  EcsServiceRole:
    Type: "AWS::IAM::Role"
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: "Allow"
            Principal: 
              Service: [ "ecs.amazonaws.com" ]
            Action: [ "sts:AssumeRole" ]
      Path: "/"
      ManagedPolicyArns:
        - "arn:aws:iam::aws:policy/service-role/AmazonEC2ContainerServiceRole"
  ElasticsearchTaskDefinition:
    Type: "AWS::ECS::TaskDefinition"
    Properties:
      NetworkMode: host
      Volumes:
        - Name: esdata
          Host: 
            SourcePath: /ecs/esdata
      ContainerDefinitions:
      - Name: elasticsearch
        Image:
          Fn::Sub: ${ElasticsearchDockerImage}:${ElasticsearchDockerImageTag}
        MemoryReservation: 500
        LogConfiguration:
          LogDriver: awslogs
          Options:
            awslogs-group: 
              Fn::Sub: ${AWS::StackName}/ecs/ElasticsearchService/elasticsearch
            awslogs-region: { "Ref": "AWS::Region" }
            awslogs-stream-prefix: docker
        PortMappings:
        - ContainerPort: { "Ref": "ElasticsearchPort" }
          Protocol: tcp
        MountPoints:
          - SourceVolume: esdata
            ContainerPath: /var/lib/elasticsearch/data
  ElasticsearchService:
    Type: "AWS::ECS::Service"
    DependsOn:
      - ApplicationLoadBalancer
      - ElasticsearchClusterAutoscalingGroup
      - ElasticsearchServiceLogGroup
    Properties:
      Cluster: { "Ref": "ElasticsearchClusterEcsCluster" }
      TaskDefinition: { "Ref": "ElasticsearchTaskDefinition" }
      DesiredCount: { "Ref": "ElasticsearchDesiredCount"}
      DeploymentConfiguration:
          MinimumHealthyPercent:
            Fn::If:
              - "ElasticsearchSingleInstanceCondition"
              - 0
              - 50
          MaximumPercent: 200
      LoadBalancers:
        - ContainerName: elasticsearch
          ContainerPort: { "Ref": "ElasticsearchPort" }
          TargetGroupArn: { "Ref": "ElasticsearchServiceTargetGroup" }
      Role: { "Ref": "EcsServiceRole" }
  DbCreateTask:
    Type: "Custom::ECSTask"
    DependsOn:
      - ApplicationClusterAutoscalingGroup
      - ApplicationDatabase
    Properties:
      ServiceToken:
        Fn::Sub: ${ApplicationClusterEcsTaskRunner.Arn}
      Cluster:
        Ref: ApplicationClusterEcsCluster
      TaskDefinition:
        Ref: AdhocTaskDefinition
      Count: 1
      Overrides:
        containerOverrides:
          - name: intake-api
            command:
              - bundle
              - exec
              - rake
              - db:create
  DbMigrateTask:
    Type: "Custom::ECSTask"
    DependsOn:
      - DbCreateTask
    Properties:
      ServiceToken:
        Fn::Sub: ${ApplicationClusterEcsTaskRunner.Arn}
      Cluster:
        Ref: ApplicationClusterEcsCluster
      TaskDefinition:
        Ref: AdhocTaskDefinition
      Count: 1
      Overrides:
        containerOverrides:
          - name: intake-api
            command:
              - bundle
              - exec
              - rake
              - db:migrate
  SearchMigrateTask:
    Type: "Custom::ECSTask"
    DependsOn:
      - DbMigrateTask
      - ElasticsearchService
    Properties:
      ServiceToken:
        Fn::Sub: ${ApplicationClusterEcsTaskRunner.Arn}
      Cluster:
        Ref: ApplicationClusterEcsCluster
      TaskDefinition: { "Ref": "AdhocTaskDefinition" }
      Count: 1
      Overrides:
        containerOverrides:
          - name: intake-api
            command:
              - bundle
              - exec
              - rake
              - search:migrate
  SearchReindexTask:
    Type: Custom::ECSTask
    DependsOn:
      - SearchMigrateTask
    Properties:
      ServiceToken:
        Fn::Sub: ${ApplicationClusterEcsTaskRunner.Arn}
      Cluster:
        Ref: ApplicationClusterEcsCluster
      TaskDefinition:
        Ref: AdhocTaskDefinition
      Count: 1
      Overrides:
        containerOverrides:
          - name: intake-api
            command:
              - bundle
              - exec
              - rake
              - search:reindex
      RetentionInDays: { "Ref": "LogRetention" }
  IntakeApiServiceLogGroup:
    Type: "AWS::Logs::LogGroup"
    DeletionPolicy: Delete
    Properties:
      LogGroupName:
        Fn::Sub: ${AWS::StackName}/ecs/IntakeApiService/intake-api
      RetentionInDays: { "Ref": "LogRetention" }
  IntakeApiNginxLogGroup:
    Type: "AWS::Logs::LogGroup"
    DeletionPolicy: Delete
    Properties:
      LogGroupName:
        Fn::Sub: ${AWS::StackName}/ecs/IntakeApiService/nginx
      RetentionInDays: { "Ref": "LogRetention" }
  IntakeApiAdhocLogGroup:
    Type: "AWS::Logs::LogGroup"
    DeletionPolicy: Delete
    Properties:
      LogGroupName:
        Fn::Sub: ${AWS::StackName}/ecs/IntakeApiService/adhoc
      RetentionInDays: { "Ref": "LogRetention" }
  ElasticsearchServiceLogGroup:
    Type: "AWS::Logs::LogGroup"
    DeletionPolicy: Delete
    Properties:
      LogGroupName:
        Fn::Sub: ${AWS::StackName}/ecs/ElasticsearchService/elasticsearch
      RetentionInDays: { "Ref": "LogRetention" }
  DbPasswordDecrypt:
    Type: "Custom::KMSDecrypt"
    Properties:
      ServiceToken: 
        Fn::Sub: ${KMSDecrypter.Arn}
      Ciphertext: { "Ref": "DbPassword" }
  KMSDecrypterLogGroup:
    Type: "AWS::Logs::LogGroup"
    DeletionPolicy: Delete
    Properties:
      LogGroupName:
        Fn::Sub: /aws/lambda/${AWS::StackName}-cfnKmsDecrypt
      RetentionInDays: { "Ref": "LogRetention" }
  KMSDecrypter:
    Type: "AWS::Lambda::Function"
    DependsOn:
      - "KMSDecrypterLogGroup"
    Properties:
      Description: 
        Fn::Sub: "${AWS::StackName} KMS Decrypter"
      Handler: "cfn_kms_decrypt.handler"
      MemorySize: 128
      Runtime: "python2.7"
      Timeout: 300
      Role: 
        Fn::Sub: ${KMSDecrypterRole.Arn}
      FunctionName: 
        Fn::Sub: "${AWS::StackName}-cfnKmsDecrypt"
      Code:
        S3Bucket: 
          Fn::Sub: "${AWS::AccountId}-cfn-lambda"
        S3Key: "cfnKmsDecrypt.zip"
        S3ObjectVersion: { "Ref": "LambdaCfnKmsDecryptVersion" }
  KMSDecrypterRole:
    Type: "AWS::IAM::Role"
    Properties:
      Path: "/"
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
        - Effect: "Allow"
          Principal: {"Service": "lambda.amazonaws.com"}
          Action: [ "sts:AssumeRole" ]
      Policies:
      - PolicyName: "KMSDecrypterPolicy"
        PolicyDocument:
          Version: "2012-10-17"
          Statement:
          - Sid: "Decrypt"
            Effect: "Allow"
            Action:
            - "kms:Decrypt"
            - "kms:DescribeKey"
            Resource:
              Fn::ImportValue: "CfnMasterKeyArn"
          - Sid: "ManageLambdaLogs"
            Effect: "Allow"
            Action:
            - "logs:CreateLogStream"
            - "logs:DescribeLogStreams"
            - "logs:PutLogEvents"
            Resource: 
              Fn::Sub: "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/${AWS::StackName}-cfnKmsDecrypt:*:*"
